pipeline {
    agent any
    
    parameters {
        string(name: 'IMAGE_NAME', description: 'Docker image name to deploy')
        string(name: 'IMAGE_TAG', description: 'Docker image tag to deploy')
        choice(name: 'DEPLOYMENT_ENV', choices: ['dev', 'staging', 'production'], description: 'Environment to deploy to')
        string(name: 'REPLICAS', defaultValue: '1', description: 'Number of replicas to deploy')
        booleanParam(name: 'ENABLE_MONITORING', defaultValue: true, description: 'Enable Prometheus metrics')
        string(name: 'RESOURCE_CPU_LIMIT', defaultValue: '1000m', description: 'CPU limit for the container')
        string(name: 'RESOURCE_MEMORY_LIMIT', defaultValue: '2Gi', description: 'Memory limit for the container')
        text(name: 'CUSTOM_ENVIRONMENT_VARS', defaultValue: 'MODEL_CACHE_ENABLED=true\nLOG_LEVEL=info', description: 'Custom environment variables (key=value format)')
    }
    
    environment {
        REGISTRY = "${params.DEPLOYMENT_ENV == 'production' ? 'production-registry:8081' : 'localhost:8081'}"
        DOCKER_REPO_NAME = "docker-hosted"
        DEPLOYMENT_NAME = "${params.IMAGE_NAME}-${params.DEPLOYMENT_ENV}"
        TELEGRAM_TOKEN = credentials('Telegram_Bot_Token')
        TELEGRAM_CHAT_ID = credentials('Chat_id')
        MODEL_API_PORT = "8000"
    }
    
    stages {
        stage('Validate Parameters') {
            steps {
                script {
                    echo "=== Deployment Configuration ==="
                    echo "Image: ${params.IMAGE_NAME}:${params.IMAGE_TAG}"
                    echo "Environment: ${params.DEPLOYMENT_ENV}"
                    echo "Replicas: ${params.REPLICAS}"
                    
                    // Validate image exists in registry
                    withCredentials([usernamePassword(credentialsId: 'nexus-credentials', usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASSWORD')]) {
                        // Use sh to construct the curl command safely
                        def cmd = 'curl -s -u $NEXUS_USER:$NEXUS_PASSWORD ' +
                                  '-X GET "' + env.REGISTRY + '/v2/' + env.DOCKER_REPO_NAME + '/' + params.IMAGE_NAME + '/manifests/' + params.IMAGE_TAG + '" ' +
                                  '-H "Accept: application/vnd.docker.distribution.manifest.v2+json" ' +
                                  '-w "%{http_code}" -o /dev/null'
                        
                        def imageExists = sh(script: cmd, returnStdout: true).trim()
                        
                        if (imageExists != "200") {
                            echo "Image check failed with status: ${imageExists}"
                            echo "This might be because the image doesn't exist or because of a connection issue."
                            
                            def userChoice = input message: 'âš ï¸ Image validation failed. Continue anyway?', 
                                              ok: 'Continue', 
                                              parameters: [choice(choices: 'Yes\nNo', description: 'Select action', name: 'continueDeployment')]
                            if (userChoice == 'No') {
                                error("Deployment stopped due to failed image validation")
                            } else {
                                echo "âš ï¸ Continuing despite image validation issues"
                            }
                        }
                    }
                }
            }
        }
        
        stage('Prepare Docker Deployment') {
            steps {
                script {
                    echo "=== Preparing Docker Deployment ==="
                    
                    // Create deployment directory
                    sh "mkdir -p deployment/${params.DEPLOYMENT_ENV}"
                    
                    // Parse custom environment variables
                    def envVars = []
                    params.CUSTOM_ENVIRONMENT_VARS.split('\n').each { line ->
                        def parts = line.split('=', 2)
                        if (parts.length == 2) {
                            envVars.add([name: parts[0].trim(), value: parts[1].trim()])
                        }
                    }
                    
                    // Add standard environment variables
                    envVars.add([name: 'DEPLOYMENT_ENV', value: params.DEPLOYMENT_ENV])
                    envVars.add([name: 'MODEL_NAME', value: params.IMAGE_NAME.replaceAll('ml-model-', '')])
                    
                    if (params.ENABLE_MONITORING) {
                        envVars.add([name: 'ENABLE_METRICS', value: 'true'])
                        envVars.add([name: 'METRICS_PORT', value: '9090'])
                    }
                    
                    // Calculate CPU limit as decimal
                    def cpuLimitValue = (params.RESOURCE_CPU_LIMIT.replace('m', '') as int) / 1000
                    
                    // Generate Docker Compose file for standalone servers
                    sh """
                        cat > deployment/${params.DEPLOYMENT_ENV}/docker-compose.yml << EOF
version: '3.8'

services:
  model-server:
    image: ${REGISTRY}/${DOCKER_REPO_NAME}/${params.IMAGE_NAME}:${params.IMAGE_TAG}
    container_name: ${params.IMAGE_NAME}
    restart: always
    ports:
      - "${MODEL_API_PORT}:${MODEL_API_PORT}"
      ${params.ENABLE_MONITORING ? '- "9090:9090"' : ''}
    environment:
      ${params.CUSTOM_ENVIRONMENT_VARS.replace('\n', '\n      ')}
      DEPLOYMENT_ENV: ${params.DEPLOYMENT_ENV}
      MODEL_NAME: ${params.IMAGE_NAME.replaceAll('ml-model-', '')}
      ${params.ENABLE_MONITORING ? 'ENABLE_METRICS: "true"\n      METRICS_PORT: "9090"' : ''}
    deploy:
      resources:
        limits:
          cpus: '${cpuLimitValue}'
          memory: ${params.RESOURCE_MEMORY_LIMIT}
      replicas: ${params.REPLICAS}
EOF

                        cat > deployment/${params.DEPLOYMENT_ENV}/deploy.sh << EOF
#!/bin/bash
set -e

echo "Deploying ${params.IMAGE_NAME}:${params.IMAGE_TAG} to ${params.DEPLOYMENT_ENV} server"

# Pull the latest image
docker login ${REGISTRY} -u \${NEXUS_USER} -p \${NEXUS_PASSWORD}
docker-compose pull

# Deploy with zero downtime
docker-compose up -d --no-deps --force-recreate model-server

echo "Deployment completed successfully"
EOF
                        chmod +x deployment/${params.DEPLOYMENT_ENV}/deploy.sh
                    """
                }
            }
        }
        
        stage('Deploy to Docker') {
            steps {
                script {
                    echo "=== Deploying to Standalone Server ==="
                    
                    // Deploy to server using SSH
                    withCredentials([
                        sshUserPrivateKey(credentialsId: "${params.DEPLOYMENT_ENV}-ssh-key", keyFileVariable: 'SSH_KEY'),
                        usernamePassword(credentialsId: 'nexus-credentials', usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASSWORD')
                    ]) {
                        def serverHost = "${params.DEPLOYMENT_ENV}-server.example.com"
                        def deploymentDir = "/opt/ml-models/${params.IMAGE_NAME}"
                        
                        sh """
                            # Create deployment directory on remote server
                            ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no deployer@${serverHost} "mkdir -p ${deploymentDir}"
                            
                            # Copy deployment files
                            scp -i ${SSH_KEY} -o StrictHostKeyChecking=no deployment/${params.DEPLOYMENT_ENV}/docker-compose.yml deployer@${serverHost}:${deploymentDir}/
                            scp -i ${SSH_KEY} -o StrictHostKeyChecking=no deployment/${params.DEPLOYMENT_ENV}/deploy.sh deployer@${serverHost}:${deploymentDir}/
                            
                            # Run deployment script
                            ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no deployer@${serverHost} "cd ${deploymentDir} && NEXUS_USER=${NEXUS_USER} NEXUS_PASSWORD=${NEXUS_PASSWORD} ./deploy.sh"
                            
                            echo "=== Service Endpoint ==="
                            echo "http://${serverHost}:${MODEL_API_PORT}"
                        """
                    }
                }
            }
        }
        
        stage('Run Health Checks') {
            steps {
                script {
                    echo "=== Running Health Checks ==="
                    
                    withCredentials([sshUserPrivateKey(credentialsId: "${params.DEPLOYMENT_ENV}-ssh-key", keyFileVariable: 'SSH_KEY')]) {
                        def serverHost = "${params.DEPLOYMENT_ENV}-server.example.com"
                        
                        sh """
                            # Run health check via SSH
                            ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no deployer@${serverHost} "curl -s http://localhost:${MODEL_API_PORT}/health" > health_check.json || echo "Health check failed" > health_check.json
                        """
                    }
                    
                    // Analyze health check results
                    def healthStatus = readFile('health_check.json').trim()
                    if (healthStatus.contains("status") && healthStatus.contains("ok")) {
                        echo "âœ… Health check passed"
                    } else {
                        echo "âš ï¸ Health check did not return expected status"
                        
                        // Ask if we should continue
                        def userChoice = input message: 'âš ï¸ Health check did not pass. Continue anyway?', 
                                          ok: 'Continue', 
                                          parameters: [choice(choices: 'No\nYes', description: 'Select action', name: 'continueDeployment')]
                        if (userChoice == 'No') {
                            error("Deployment stopped due to failed health check")
                        } else {
                            echo "âš ï¸ Continuing despite health check issues"
                        }
                    }
                }
            }
        }
        
        stage('Configure Monitoring') {
            when {
                expression { return params.ENABLE_MONITORING == true }
            }
            steps {
                script {
                    echo "=== Setting up Monitoring for Docker Deployment ==="
                    
                    withCredentials([sshUserPrivateKey(credentialsId: "${params.DEPLOYMENT_ENV}-ssh-key", keyFileVariable: 'SSH_KEY')]) {
                        def serverHost = "${params.DEPLOYMENT_ENV}-server.example.com"
                        
                        sh """
                            # Create Prometheus config for model
                            cat > deployment/${params.DEPLOYMENT_ENV}/prometheus-job.yml << EOF
- job_name: '${params.IMAGE_NAME}'
  scrape_interval: 15s
  static_configs:
    - targets: ['localhost:9090']
  metrics_path: /metrics
  labels:
    env: '${params.DEPLOYMENT_ENV}'
    model: '${params.IMAGE_NAME.replaceAll('ml-model-', '')}'
EOF

                            # Add to server Prometheus config
                            scp -i ${SSH_KEY} -o StrictHostKeyChecking=no deployment/${params.DEPLOYMENT_ENV}/prometheus-job.yml deployer@${serverHost}:/tmp/
                            ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no deployer@${serverHost} "cat /tmp/prometheus-job.yml >> /etc/prometheus/jobs/${params.IMAGE_NAME}.yml && systemctl restart prometheus"
                        """
                    }
                }
            }
        }
        
        stage('Register API Documentation') {
            steps {
                script {
                    echo "=== Registering API Documentation ==="
                    
                    // Generate API docs URL
                    def apiDocsUrl = "http://${params.DEPLOYMENT_ENV}-server.example.com:${MODEL_API_PORT}/docs"
                    
                    // Register in central API catalog
                    withCredentials([string(credentialsId: 'api-catalog-token', variable: 'API_CATALOG_TOKEN')]) {
                        sh """
                            # Create API metadata
                            cat > api-metadata.json << EOF
{
  "name": "${params.IMAGE_NAME.replaceAll('ml-model-', '')}",
  "version": "${params.IMAGE_TAG}",
  "environment": "${params.DEPLOYMENT_ENV}",
  "description": "ML model API for ${params.IMAGE_NAME.replaceAll('ml-model-', '')}",
  "endpoints": [
    {
      "path": "/predict",
      "method": "POST",
      "description": "Make predictions with the model"
    },
    {
      "path": "/health",
      "method": "GET",
      "description": "Check model health"
    }
  ],
  "documentation_url": "${apiDocsUrl}",
  "deployed_at": "\$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
}
EOF

                            # Register with API catalog
                            curl -X POST "http://api-catalog.example.com/api/v1/register" \
                                -H "Authorization: Bearer ${API_CATALOG_TOKEN}" \
                                -H "Content-Type: application/json" \
                                -d @api-metadata.json
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                // Create deployment summary
                sh """
                    # Create deployment summary
                    cat > deployment-summary.md << EOF
## Deployment Summary

**Model**: ${params.IMAGE_NAME}:${params.IMAGE_TAG}
**Environment**: ${params.DEPLOYMENT_ENV}
**Replicas**: ${params.REPLICAS}
**Monitoring**: ${params.ENABLE_MONITORING ? 'Enabled' : 'Disabled'}

### Endpoints
- API: http://${params.DEPLOYMENT_ENV}-server.example.com:${MODEL_API_PORT}/
- Documentation: http://${params.DEPLOYMENT_ENV}-server.example.com:${MODEL_API_PORT}/docs

### Resource Allocation
- CPU: ${params.RESOURCE_CPU_LIMIT}
- Memory: ${params.RESOURCE_MEMORY_LIMIT}

EOF
                """
                
                // Archive deployment artifacts
                archiveArtifacts artifacts: 'deployment/**/*,*-summary.md,health_check.json', fingerprint: true
                
                // Send notification
                sh """
                    # Send deployment notification
                    curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
                        -d chat_id=${TELEGRAM_CHAT_ID} \
                        -d parse_mode=Markdown \
                        -d text="âœ… *Model Deployed Successfully!* ðŸš€\\n\\n*Model:* ${params.IMAGE_NAME}:${params.IMAGE_TAG}\\n*Environment:* ${params.DEPLOYMENT_ENV}\\n\\n*Access via:* http://${params.DEPLOYMENT_ENV}-server.example.com:${MODEL_API_PORT}/"
                """
            }
        }
        
        failure {
            script {
                // Send failure notification
                sh """
                    # Send deployment failure notification
                    curl -s -X POST "https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage" \
                        -d chat_id=${TELEGRAM_CHAT_ID} \
                        -d parse_mode=Markdown \
                        -d text="âŒ *Model Deployment Failed!* ðŸš¨\\n\\n*Model:* ${params.IMAGE_NAME}:${params.IMAGE_TAG}\\n*Environment:* ${params.DEPLOYMENT_ENV}\\n\\n[View Logs](${env.BUILD_URL}console)"
                """
                
                // Archive any artifacts that might have been created
                archiveArtifacts artifacts: 'deployment/**/*,*-summary.md,health_check.json', allowEmptyArchive: true
            }
        }
        
        always {
            cleanWs()
        }
    }
}
